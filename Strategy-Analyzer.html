<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OOStrategy Analyzer v10</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Montserrat:wght@600;700&display=swap" rel="stylesheet">

<!-- Plotly (interactive charts) -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<!-- PapaParse (CSV parsing) -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<!-- Luxon (date parsing) -->
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>

<!-- SheetJS + FileSaver (table downloads) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<style>
  :root {
    --bg: #0e1014;
    --panel: #151922;
    --panel-2: #0f131a;
    --text: #e6e8ef;
    --muted: #9aa3b2;
    --accent: #3b82f6;
    --accent-2: #22d3ee;
    --border: #232938;
    --chip: #1f2533;
    --table-head: #1b2130;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; background: var(--bg); color: var(--text); font-family: 'Roboto', system-ui, -apple-system, Segoe UI, Arial, sans-serif; margin: 0; }
  h1, h2, h3 { font-family: 'Montserrat', Roboto, sans-serif; letter-spacing: .3px; }
  .container { max-width: 1300px; margin: 24px auto 64px; padding: 0 16px; }
  .titlebar { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
  .logo-dot { width:14px; height:14px; border-radius:50%; background:linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow:0 0 18px rgba(34,211,238,.55); }
  .panel { background: linear-gradient(180deg, var(--panel), var(--panel-2) 120%); border:1px solid var(--border); border-radius:16px; padding:14px 14px 8px; box-shadow:0 10px 30px rgba(0,0,0,.35); margin-bottom:18px; }
  .row { display:grid; gap:10px; margin:6px 0; }
  .row-1 { grid-template-columns: 1fr; }
  .row-2 { grid-template-columns: repeat(3, max-content); align-items:center; gap:14px; }
  .row-3 { grid-template-columns: repeat(2, max-content); align-items:center; gap:12px; }
  input[type="file"] { display:none; }
  .btn { background:#1f2533; color:var(--text); border:1px solid var(--border); padding:10px 14px; border-radius:12px; cursor:pointer; transition:.2s border-color, .04s transform; font-weight:500; }
  .btn:hover { border-color:#22d3ee; } .btn:active { transform: translateY(1px); } .btn.primary{ background:linear-gradient(180deg,#1f3b79,#163160); border-color:#1c3270; } .btn[disabled]{ opacity:.5; cursor:not-allowed; }
  .date-label{ color:#9aa3b2; font-size:.9rem; margin-right:8px; }
  .date-input{ background:#1f2533; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 10px; }
  .card{ background: linear-gradient(180deg, var(--panel), var(--panel-2) 120%); border:1px solid var(--border); border-radius:16px; padding:12px; box-shadow:0 10px 26px rgba(0,0,0,.33); margin-bottom:16px; }
  .toolbar{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; padding:8px 10px; }
  .segmented{ display:inline-flex; background:#1f2533; border:1px solid var(--border); border-radius:12px; overflow:hidden; }
  .segmented button{ border:none; background:transparent; color:var(--text); padding:8px 12px; font-weight:500; cursor:pointer; }
  .segmented button.active{ background:#3b82f6; }
  .ranges{ display:inline-flex; gap:6px; margin-left:auto; }
  .table-wrap{ border:1px solid var(--border); background:#0f131a; border-radius:12px; overflow:auto; max-height:440px; }
  table{ width:100%; border-collapse:collapse; min-width:640px; }
  thead{ position:sticky; top:0; background:#1b2130; z-index:1; }
  th,td{ border-bottom:1px solid var(--border); padding:10px; text-align:right; white-space:nowrap; }
  th:first-child,td:first-child{ text-align:left; }
</style>
</head>
<body>
  <div class="container">
    <div class="titlebar">
      <div class="logo-dot"></div>
      <div>
        <h1 style="margin:0">OOStrategy Analyzer</h1>
        <div style="color:#9aa3b2">v10</div>
      </div>
      <span class="tag" id="statusTag" style="margin-left:8px;background:#1f2533;border:1px solid #232938;border-radius:16px;padding:6px 10px;color:#9aa3b2;">Ready</span>
    </div>

    <div class="panel">
      <div class="row row-1">
        <label class="btn primary" for="fileInput">Upload CSV files</label>
        <input id="fileInput" type="file" accept=".csv" multiple />
        <span class="hint">First col = Date, second = Time Opened, and <strong>Funds at Close</strong> = NAV/price.</span>
      </div>
      <div class="row row-2">
        <div><label class="date-label" for="startDate">Start date</label><input id="startDate" class="date-input" type="date" /></div>
        <div><label class="date-label" for="endDate">End date</label><input id="endDate" class="date-input" type="date" /></div>
        <button class="btn" id="fullRangeBtn">Full range</button>
      </div>
      <div class="row row-3">
        <button class="btn" id="downloadMergedUnionBtn" disabled>Download merged_union.csv (union dates)</button>
        <button class="btn" id="downloadCombinedBtn" disabled>Download combined_strategy.csv</button>
      </div>
    </div>

    <div class="card">
      <div class="toolbar">
        <h3 style="margin-right:8px;">Cumulative Returns</h3>
        <div class="segmented" id="cumModeToggle">
          <button data-mode="simple" class="active">Simple</button>
          <button data-mode="log">Log</button>
        </div>
        <div class="ranges">
          <button class="btn" data-range="10y">10Y</button>
          <button class="btn" data-range="5y">5Y</button>
          <button class="btn" data-range="1y">1Y</button>
          <button class="btn" data-range="ytd">YTD</button>
          <button class="btn" data-range="all">All</button>
        </div>
      </div>
      <div id="cumChart" style="width:100%;height:460px;"></div>
    </div>

    <div class="card">
      <div class="toolbar">
        <h3>Drawdowns</h3>
      </div>
      <div id="ddChart" style="width:100%;height:420px;"></div>
    </div>

    <div class="card">
      <div class="toolbar">
        <h3 style="margin-right:auto;">Financial Stats</h3>
        <button class="btn" id="switchAxesBtn" title="Transpose the table">Switch axes</button>
        <button class="btn" id="downloadStatsCsv">Download CSV</button>
        <button class="btn" id="downloadStatsXlsx">Download XLSX</button>
      </div>
      <div class="table-wrap">
        <table id="statsTable"><thead></thead><tbody></tbody></table>
      </div>
    </div>

    <div class="card">
      <div class="toolbar">
        <h3 style="margin-right:auto;">Correlation Matrix (All Days, incl. Combined)</h3>
        <button class="btn" id="downloadCorrAllCsv">Download CSV</button>
        <button class="btn" id="downloadCorrAllXlsx">Download XLSX</button>
      </div>
      <div class="table-wrap">
        <table id="corrAllTable"><thead></thead><tbody></tbody></table>
      </div>
    </div>

    <div class="card">
      <div class="toolbar">
        <h3 style="margin-right:auto;">Correlation Matrix (Down Days Only)</h3>
        <small style="color:#9aa3b2;">Down days are when <strong>Combined</strong> daily return &lt; 0.</small>
        <span style="flex:1 1 auto;"></span>
        <button class="btn" id="downloadCorrDownCsv">Download CSV</button>
        <button class="btn" id="downloadCorrDownXlsx">Download XLSX</button>
      </div>
      <div class="table-wrap">
        <table id="corrDownTable"><thead></thead><tbody></tbody></table>
      </div>
    </div>
  </div>

<script>
(() => {
  const DateTime = luxon.DateTime;

  // State
  let rawSeries = {};                  // { label: Map(date -> price) }
  let labels = [];
  let unionDates = [];
  let alignedRawUnion = {};            // RAW forward-filled/backfilled prices
  let alignedNormUnion = {};           // Normalized series (per first non-null)
  let statsTranspose = localStorage.getItem('statsTranspose') === 'true';
  let cumMode = localStorage.getItem('cumMode') || 'simple';

  // DOM
  const statusTag = document.getElementById('statusTag');
  const fileInput = document.getElementById('fileInput');
  const startDateEl = document.getElementById('startDate');
  const endDateEl = document.getElementById('endDate');
  const fullRangeBtn = document.getElementById('fullRangeBtn');
  const downloadMergedUnionBtn = document.getElementById('downloadMergedUnionBtn');
  const downloadCombinedBtn = document.getElementById('downloadCombinedBtn');
  const cumModeToggle = document.getElementById('cumModeToggle');
  const rangeButtons = document.querySelectorAll('.ranges .btn');
  const switchAxesBtn = document.getElementById('switchAxesBtn');

  const GRID = 'rgba(190,195,210,0.35)';
  function setStatus(t){ statusTag.textContent = t; }

  // Utils
  function layoutWithGrid(extra={}) {
    return Object.assign({
      template: 'plotly_dark',
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      margin: {t:24,r:16,b:40,l:46},
      xaxis:{
        type:'date',
        showgrid:true, gridcolor:GRID, zerolinecolor:GRID,
        rangeselector:{ buttons:[
          {step:'year',stepmode:'backward',count:10,label:'10Y'},
          {step:'year',stepmode:'backward',count:5,label:'5Y'},
          {step:'year',stepmode:'backward',count:1,label:'1Y'},
          {step:'year',stepmode:'todate',count:1,label:'YTD'},
          {step:'all',label:'All'}
        ]},
        rangeslider:{visible:false}
      },
      yaxis:{ showgrid:true, gridcolor:GRID, zerolinecolor:GRID },
      legend:{orientation:'h',y:-0.18}
    }, extra);
  }
  function cleanNumber(v){ if(v==null) return NaN; if(typeof v==='number') return v; const n = parseFloat(String(v).replace(/[^0-9\-+.eE]/g,'')); return isFinite(n)?n:NaN; }
  function normalizeHeader(h){ return String(h||'').toLowerCase().replace(/[^a-z0-9]/g,''); }
  function parseDateFlexible(s){
    if(!s) return null;
    let dt = DateTime.fromISO(s,{zone:'utc'}); if(dt.isValid) return dt;
    const fmts=['M/d/yyyy','M/d/yy','MM/dd/yyyy','MM/dd/yy','d/M/yyyy','dd/M/yyyy','yyyy-MM-dd','yyyy/M/d'];
    for(const f of fmts){ dt = DateTime.fromFormat(s,f,{zone:'utc'}); if(dt.isValid) return dt; }
    const d = new Date(s); if(!isNaN(d.getTime())) return DateTime.fromJSDate(d,{zone:'utc'});
    return null;
  }
  function fileLabel(name){ return name.replace(/\\.[^/.]+$/,''); }
  function subsetRange(dates, arrs, d0, d1){
    const idx0 = dates.findIndex(d => d >= d0);
    const idx1 = dates.map((d,i)=>[d,i]).reverse().find(([d])=> d <= d1);
    if(idx0===-1 || !idx1) return {dates:[], arrs: arrs.map(()=>[])};
    const end = idx1[1];
    return {dates: dates.slice(idx0,end+1), arrs: arrs.map(a=> a.slice(idx0,end+1))};
  }
  function computeDailyReturns(pr){
    const r = new Array(pr.length).fill(null);
    for(let i=1;i<pr.length;i++){ const p0=pr[i-1], p1=pr[i]; if(p0==null||p1==null){ r[i]=null; continue; } r[i]= (p1/p0)-1; }
    return r;
  }
  function computeLogReturns(pr){
    const r = new Array(pr.length).fill(null);
    for(let i=1;i<pr.length;i++){ const p0=pr[i-1], p1=pr[i]; if(p0==null||p1==null){ r[i]=null; continue; } r[i]= Math.log(p1)-Math.log(p0); }
    return r;
  }
  function cumulativeFromReturns(returns, mode='simple'){
    const cum = new Array(returns.length).fill(null);
    if(mode==='simple'){ let w=1; for(let i=0;i<returns.length;i++){ if(returns[i]==null){ cum[i]=(i?cum[i-1]:null); continue; } w*=(1+returns[i]); cum[i]=w-1; } }
    else { let s=0; for(let i=0;i<returns.length;i++){ if(returns[i]==null){ cum[i]=(i?cum[i-1]:null); continue; } s+=returns[i]; cum[i]=Math.exp(s)-1; } }
    return cum;
  }
  function drawdownFromWealth(cum){ const dd=new Array(cum.length).fill(null); let peak=1; for(let i=0;i<cum.length;i++){ const c=cum[i]; if(c==null){ dd[i]=(i?dd[i-1]:null); continue; } const w=1+c; peak=Math.max(peak,w); dd[i]=(w/peak)-1; } return dd; }
  function mean(a){ const v=a.filter(x=>x!=null&&isFinite(x)); if(!v.length) return NaN; return v.reduce((p,c)=>p+c,0)/v.length; }
  function stddev(a){ const v=a.filter(x=>x!=null&&isFinite(x)); if(v.length<=1) return NaN; const m=mean(v); return Math.sqrt(v.reduce((s,x)=>s+(x-m)*(x-m),0)/(v.length-1)); }
  function downsideStd(a){ const d=a.filter(x=>x!=null&&isFinite(x)&&x<0); if(!d.length) return NaN; return Math.sqrt(d.reduce((s,x)=>s+x*x,0)/d.length); }
  function ulcerIndex(dd){ const v=dd.filter(x=>x!=null&&isFinite(x)); if(!v.length) return NaN; return Math.sqrt(mean(v.map(x=>x*x))); }
  function calcStatsFor(prices, dates){
    const returns = computeDailyReturns(prices);
    const cum = cumulativeFromReturns(returns,'simple');
    const dd = drawdownFromWealth(cum);
    const idx = returns.map((v,i)=> v!=null?i:null).filter(i=>i!=null);
    if(!idx.length) return {CAGR:NaN,maxDD:NaN,sharpe:NaN,sortino:NaN,UPI:NaN,vol:NaN,profitFactor:NaN,calmar:NaN};
    const first=idx[0], last=idx[idx.length-1];
    const startPrice=prices[first], endPrice=prices[last];
    const startDate=DateTime.fromISO(dates[first]), endDate=DateTime.fromISO(dates[last]);
    const daySpan=Math.max(1, endDate.diff(startDate,'days').days);
    const total=(endPrice/startPrice)-1;
    const CAGR=Math.pow(1+total,365/daySpan)-1;
    const mu=mean(returns), sig=stddev(returns), down=downsideStd(returns), ann=Math.sqrt(252);
    const sharpe=(sig&&isFinite(sig)&&sig!==0)?(mu/sig)*ann:NaN;
    const sortino=(down&&isFinite(down)&&down!==0)?(mu/down)*ann:NaN;
    const maxDD=Math.min(...dd.filter(v=>v!=null&&isFinite(v)));
    const UI=ulcerIndex(dd);
    const UPI=(UI&&isFinite(UI)&&UI!==0)?(CAGR/UI):NaN;
    const vol=(sig&&isFinite(sig))?sig*Math.sqrt(252):NaN;
    let pos=0,neg=0; returns.forEach(r=>{ if(r==null||!isFinite(r))return; if(r>=0)pos+=r; else neg+=r; });
    const profitFactor=(neg!==0)?(pos/Math.abs(neg)):NaN;
    const calmar=(maxDD&&isFinite(maxDD)&&maxDD!==0)?(CAGR/Math.abs(maxDD)):NaN;
    return {CAGR,maxDD,sharpe,sortino,UPI,vol,profitFactor,calmar};
  }
  function averageRetAcrossSeries(retArrays){
    const out=new Array(retArrays[0].length).fill(null);
    for(let i=0;i<out.length;i++){
      let sum=0,n=0;
      for(let k=0;k<retArrays.length;k++){
        const r=retArrays[k][i];
        if(r!=null && isFinite(r)){ sum+=r; n++; }
      }
      out[i] = n ? (sum/n) : null;
    }
    return out;
  }

  // Charts
  function renderCumChart(dates, priceMatrix, combinedRet){
    const traces=[];
    for(let k=0;k<labels.length;k++){
      const pr=priceMatrix[k];
      const rets = (cumMode==='log') ? computeLogReturns(pr) : computeDailyReturns(pr);
      const cum = cumulativeFromReturns(rets, cumMode);
      traces.push({type:'scatter', mode:'lines', name:labels[k], x:dates, y:cum, hovertemplate:'%{x}<br>%{y:.2%}<extra>'+labels[k]+'</extra>'});
    }
    if (combinedRet && combinedRet.length) {
      const cumC = cumulativeFromReturns(combinedRet, cumMode);
      traces.push({type:'scatter', mode:'lines', name:'Combined', x:dates, y:cumC, line:{width:4}, hovertemplate:'%{x}<br>%{y:.2%}<extra>Combined</extra>'});
    }
    const layout = layoutWithGrid({ yaxis: Object.assign({}, layoutWithGrid().yaxis, { tickformat: '.0%' }) });
    Plotly.newPlot('cumChart', traces, layout, {responsive:true, displaylogo:false});
  }
  function renderDDChart(dates, priceMatrix, combinedRet){
    const traces=[];
    for(let k=0;k<labels.length;k++){
      const pr=priceMatrix[k];
      const cum = cumulativeFromReturns(computeDailyReturns(pr), 'simple');
      const dd = drawdownFromWealth(cum);
      traces.push({type:'scatter', mode:'lines', name:labels[k], x:dates, y:dd, hovertemplate:'%{x}<br>%{y:.2%}<extra>'+labels[k]+'</extra>'});
    }
    if (combinedRet && combinedRet.length) {
      const cumC = cumulativeFromReturns(combinedRet, 'simple');
      const ddC = drawdownFromWealth(cumC);
      traces.push({type:'scatter', mode:'lines', name:'Combined', x:dates, y:ddC, line:{width:4}, hovertemplate:'%{x}<br>%{y:.2%}<extra>Combined</extra>'});
    }
    const layout = layoutWithGrid({ yaxis: Object.assign({}, layoutWithGrid().yaxis, { tickformat: '.0%' }) });
    Plotly.newPlot('ddChart', traces, layout, {responsive:true, displaylogo:false});
  }

  // Stats table (restored)
  function renderStatsTable(statsMap, includeCombined){
    const table=document.getElementById('statsTable');
    const thead=table.querySelector('thead'); const tbody=table.querySelector('tbody');
    thead.innerHTML=''; tbody.innerHTML='';
    const metrics=['CAGR','Max drawdown','Sharpe ratio','Sortino ratio','Ulcer Performance Index (UPI)','Volatility','Profit factor','Calmar ratio'];
    const keys=['CAGR','maxDD','sharpe','sortino','UPI','vol','profitFactor','calmar'];
    const disp = includeCombined ? labels.concat(['Combined']) : labels.slice();

    const trh=document.createElement('tr');
    if(!statsTranspose){
      trh.appendChild(Object.assign(document.createElement('th'),{textContent:'Metric'}));
      disp.forEach(lb=> trh.appendChild(Object.assign(document.createElement('th'),{textContent:lb})));
      thead.appendChild(trh);
      metrics.forEach((m,i)=>{
        const tr=document.createElement('tr');
        tr.appendChild(Object.assign(document.createElement('td'),{textContent:m}));
        disp.forEach(lb=>{
          const val=statsMap[lb]?.[keys[i]];
          const td=document.createElement('td');
          if(['CAGR','maxDD','vol'].includes(keys[i])) td.textContent=(val==null||!isFinite(val))?'—':(val*100).toFixed(2)+'%';
          else td.textContent=(val==null||!isFinite(val))?'—':val.toFixed(2);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    } else {
      trh.appendChild(Object.assign(document.createElement('th'),{textContent:'Strategy'}));
      metrics.forEach(m=> trh.appendChild(Object.assign(document.createElement('th'),{textContent:m})));
      thead.appendChild(trh);
      disp.forEach(lb=>{
        const tr=document.createElement('tr');
        tr.appendChild(Object.assign(document.createElement('td'),{textContent:lb}));
        keys.forEach(k=>{
          const val=statsMap[lb]?.[k];
          const td=document.createElement('td');
          if(['CAGR','maxDD','vol'].includes(k)) td.textContent=(val==null||!isFinite(val))?'—':(val*100).toFixed(2)+'%';
          else td.textContent=(val==null||!isFinite(val))?'—':val.toFixed(2);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }
  }

  // Correlation helpers
  function corrcoefFromArrays(x,y){
    const a=[],b=[]; for(let i=0;i<x.length&&i<y.length;i++){ const vx=x[i],vy=y[i]; if(vx!=null&&vy!=null&&isFinite(vx)&&isFinite(vy)){a.push(vx);b.push(vy);}}
    if(a.length<=1) return NaN;
    const mx=a.reduce((p,c)=>p+c,0)/a.length, my=b.reduce((p,c)=>p+c,0)/b.length;
    let num=0,vxv=0,vyv=0; for(let i=0;i<a.length;i++){ const dx=a[i]-mx, dy=b[i]-my; num+=dx*dy; vxv+=dx*dx; vyv+=dy*dy; }
    if(vxv===0||vyv===0) return NaN; return num/Math.sqrt(vxv*vyv);
  }
  function renderCorrTable(tableId, labelsList, returnsMap, filterIdx=null){
    const table=document.getElementById(tableId);
    const thead=table.querySelector('thead'); const tbody=table.querySelector('tbody');
    thead.innerHTML=''; tbody.innerHTML='';
    const trh=document.createElement('tr');
    trh.appendChild(Object.assign(document.createElement('th'),{textContent:''}));
    labelsList.forEach(lb=> trh.appendChild(Object.assign(document.createElement('th'),{textContent:lb})));
    thead.appendChild(trh);

    const seriesReturns = labelsList.map(lb => returnsMap[lb]);
    for(let i=0;i<labelsList.length;i++){
      const tr=document.createElement('tr');
      tr.appendChild(Object.assign(document.createElement('td'),{textContent:labelsList[i]}));
      for(let j=0;j<labelsList.length;j++){
        const td=document.createElement('td');
        let x = seriesReturns[i], y = seriesReturns[j];
        // Apply optional filter indices (e.g., down days)
        if (filterIdx) {
          const xf=[], yf=[];
          for (const idx of filterIdx) {
            const vx = x[idx], vy = y[idx];
            if (vx!=null && vy!=null && isFinite(vx) && isFinite(vy)) { xf.push(vx); yf.push(vy); }
          }
          x = xf; y = yf;
        }
        let corr=NaN;
        if (!filterIdx) {
          corr = corrcoefFromArrays(x,y);
        } else {
          if (x.length>1) {
            const mx=x.reduce((p,c)=>p+c,0)/x.length, my=y.reduce((p,c)=>p+c,0)/y.length;
            let num=0,vxv=0,vyv=0; for(let k=0;k<x.length;k++){ const dx=x[k]-mx, dy=y[k]-my; num+=dx*dy; vxv+=dx*dx; vyv+=dy*dy; }
            if(vxv!==0 && vyv!==0) corr=num/Math.sqrt(vxv*vyv);
          }
        }
        td.textContent = (i===j) ? '1.00' : (isFinite(corr) ? corr.toFixed(2) : '—');
        if (i!==j && isFinite(corr)) {
          if (corr <= 0.6) td.style.background='rgba(34,197,94,.22)';
          else if (corr <= 0.8) td.style.background='rgba(234,179,8,.22)';
          else if (corr < 1.0) td.style.background='rgba(239,68,68,.22)';
        }
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }

  function rebuildAll(){
    if(!labels.length || !unionDates.length) return;
    const allDates=unionDates, matrices=labels.map(lb=> alignedNormUnion[lb]);
    const d0=startDateEl.value || allDates[0];
    const d1=endDateEl.value || allDates[allDates.length-1];
    const sub=subsetRange(allDates, matrices, d0, d1);
    const dates=sub.dates, priceMatrix=sub.arrs;
    if(!dates.length) return;

    // Per-strategy rets (normalized), then Combined
    const retMap={};
    for(let k=0;k<labels.length;k++) retMap[labels[k]] = computeDailyReturns(priceMatrix[k]);
    const combinedRet = averageRetAcrossSeries(Object.values(retMap));

    renderCumChart(dates, priceMatrix, combinedRet);
    renderDDChart(dates, priceMatrix, combinedRet);

    // Stats: per label + combined
    const statsMap={};
    for(let k=0;k<labels.length;k++){
      const lb=labels[k], pr=priceMatrix[k];
      statsMap[lb]=calcStatsFor(pr, dates);
    }
    const combinedNAV = cumulativeFromReturns(combinedRet, 'simple').map(c=> c==null? null : 1+c);
    statsMap['Combined'] = calcStatsFor(combinedNAV, dates);
    renderStatsTable(statsMap, true);

    // Correlations (ALL DAYS): include Combined
    const labelsAll = labels.concat(['Combined']);
    const returnsAll = Object.assign({}, retMap, { Combined: combinedRet });
    renderCorrTable('corrAllTable', labelsAll, returnsAll, null);

    // Correlations (DOWN DAYS): filter indices where Combined < 0
    const downIdx = [];
    for (let i=0;i<combinedRet.length;i++) if (combinedRet[i] != null && isFinite(combinedRet[i]) && combinedRet[i] < 0) downIdx.push(i);
    renderCorrTable('corrDownTable', labelsAll, returnsAll, downIdx);
  }

  // Downloads for tables (generic)
  function downloadTableCsv(tableId, filenameBase){
    const table=document.getElementById(tableId);
    const thead=table.querySelector('thead'); const tbody=table.querySelector('tbody');
    const data=[];
    data.push(Array.from(thead.querySelectorAll('th')).map(th=>th.textContent));
    Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
      data.push(Array.from(tr.querySelectorAll('td')).map(td=>td.textContent));
    });
    const ws=XLSX.utils.aoa_to_sheet(data);
    const csv=XLSX.utils.sheet_to_csv(ws);
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    saveAs(blob, filenameBase+'.csv');
  }
  function downloadTableXlsx(tableId, filenameBase){
    const table=document.getElementById(tableId);
    const thead=table.querySelector('thead'); const tbody=table.querySelector('tbody');
    const data=[];
    data.push(Array.from(thead.querySelectorAll('th')).map(th=>th.textContent));
    Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
      data.push(Array.from(tr.querySelectorAll('td')).map(td=>td.textContent));
    });
    const ws=XLSX.utils.aoa_to_sheet(data);
    const wb=XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb,ws,'Sheet1');
    const wbout=XLSX.write(wb,{bookType:'xlsx',type:'array'});
    saveAs(new Blob([wbout],{type:'application/octet-stream'}), filenameBase+'.xlsx');
  }

  // Raw union CSV
  function csvFromUnionRaw(dates, labels, rawMap){
    const header=['Date',...labels].join(',')+'\\n';
    const rows=dates.map((d,i)=> [d, ...labels.map(lb => rawMap[lb][i] ?? '')].join(','));
    return header + rows.join('\\n');
  }

  // Event pipeline
  fileInput.addEventListener('change', async (e)=>{
    const files=Array.from(e.target.files||[]);
    if(!files.length) return;
    setStatus('Parsing...');
    rawSeries={}; labels=[];
    for(const f of files){
      const label=fileLabel(f.name); labels.push(label);
      const text=await f.text();
      const parsed=Papa.parse(text,{header:true,skipEmptyLines:true});
      const rows=parsed.data; const headers=parsed.meta.fields||[];
      const dateHeader=headers[0];
      const fundsIndex=headers.findIndex(h => {
        const nh=normalizeHeader(h);
        return nh==='fundsatclose'||nh==='nav'||nh==='netassetvalue'||nh==='fundsclose';
      });
      const fundsHeader = fundsIndex>=0 ? headers[fundsIndex] : 'Funds at Close';
      const m=new Map();
      for(const row of rows){
        const dt=parseDateFlexible(row[dateHeader]);
        if(!dt) continue;
        const d = dt.toISODate();
        const v = cleanNumber(row[fundsHeader] ?? row['Funds at Close']);
        if(!isFinite(v)) continue;
        m.set(d,v);
      }
      rawSeries[label]=m;
    }

    // Oldest common start = max of per-series first dates
    const minDates=Object.values(rawSeries).map(m=> Array.from(m.keys()).sort((a,b)=>a.localeCompare(b))[0]).filter(Boolean);
    const start = minDates.length ? minDates.reduce((a,b)=> a>b?a:b) : null;
    if(!start){ setStatus('Could not determine a common start date.'); return; }

    // Build union calendar from start
    const uSet=new Set();
    Object.values(rawSeries).forEach(m=>{ for(const d of m.keys()) if(d>=start) uSet.add(d); });
    unionDates=Array.from(uSet).sort((a,b)=>a.localeCompare(b));
    if(!unionDates.length){ setStatus('No union dates.'); return; }

    // RAW ffill with seed from last price <= start (if any)
    alignedRawUnion={}; alignedNormUnion={};
    for(const lb of labels){
      const m=rawSeries[lb];
      // seed
      let seed=null;
      const sortedKeys=Array.from(m.keys()).sort((a,b)=>a.localeCompare(b));
      for(const d of sortedKeys){ if(d<=start) seed=m.get(d); else break; }
      // forward fill across unionDates
      const arr=new Array(unionDates.length).fill(null);
      let last=seed;
      for(let i=0;i<unionDates.length;i++){
        const d=unionDates[i];
        if(m.has(d)) last=m.get(d);
        arr[i]=(last!=null)?last:null;
      }
      alignedRawUnion[lb]=arr;

      // Normalize per first non-null in arr
      let baseIdx = arr.findIndex(v => v!=null && isFinite(v));
      if(baseIdx === -1){ alignedNormUnion[lb]=arr.map(_=>null); }
      else {
        const base=arr[baseIdx];
        alignedNormUnion[lb]=arr.map((v,i)=> v==null? null : v/base);
      }
    }

    // Set selectors
    startDateEl.value=unionDates[0];
    endDateEl.value=unionDates[unionDates.length-1];

    // Enable downloads
    downloadMergedUnionBtn.disabled=false;
    downloadCombinedBtn.disabled=false;

    setStatus(`Loaded ${labels.length} file(s). Common start: ${start}. Union dates: ${unionDates.length}`);
    rebuildAll();

    // Handlers
    const onChange=()=>rebuildAll();
    startDateEl.onchange=onChange;
    endDateEl.onchange=onChange;
    fullRangeBtn.onclick=()=>{ startDateEl.value=unionDates[0]; endDateEl.value=unionDates[unionDates.length-1]; rebuildAll(); };

    // Switch axes toggle (persist)
    switchAxesBtn.onclick = () => {
      statsTranspose = !statsTranspose;
      localStorage.setItem('statsTranspose', String(statsTranspose));
      rebuildAll();
    };

    document.getElementById('downloadStatsCsv').onclick=()=> downloadTableCsv('statsTable','financial_stats');
    document.getElementById('downloadStatsXlsx').onclick=()=> downloadTableXlsx('statsTable','financial_stats');
    document.getElementById('downloadCorrAllCsv').onclick=()=> downloadTableCsv('corrAllTable','correlation_matrix_all_days');
    document.getElementById('downloadCorrAllXlsx').onclick=()=> downloadTableXlsx('corrAllTable','correlation_matrix_all_days');
    document.getElementById('downloadCorrDownCsv').onclick=()=> downloadTableCsv('corrDownTable','correlation_matrix_down_days');
    document.getElementById('downloadCorrDownXlsx').onclick=()=> downloadTableXlsx('corrDownTable','correlation_matrix_down_days');

    downloadMergedUnionBtn.onclick=()=>{
      const csv = csvFromUnionRaw(unionDates, labels, alignedRawUnion);
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
      saveAs(blob, 'merged_union.csv');
    };

    downloadCombinedBtn.onclick=()=>{
      // Build combined CSV using normalized series and daily rebalanced equal weights
      const retArrays = labels.map(lb => computeDailyReturns(alignedNormUnion[lb]));
      const combinedRet = averageRetAcrossSeries(retArrays);
      const combinedLogRet = combinedRet.map(r => (r==null? null : Math.log(1+r)));
      const combinedNAV = cumulativeFromReturns(combinedRet,'simple').map(c => (c==null? null : 1+c));

      const header = [
        'Date','Combined_NAV','Combined_Daily_Return','Combined_Log_Return',
        ...labels.map(lb=> lb+'_NAV'),
        ...labels.map(lb=> lb+'_Ret'),
        ...labels.map(lb=> lb+'_LogRet')
      ].join(',')+'\\n';

      const perLabelRets = Object.fromEntries(labels.map(lb=> [lb, computeDailyReturns(alignedNormUnion[lb]) ]));
      const perLabelLogRets = Object.fromEntries(labels.map(lb=> [lb, computeLogReturns(alignedNormUnion[lb]) ]));

      const rows = unionDates.map((d,i)=>{
        const base=[d,
          (combinedNAV[i]==null?'':combinedNAV[i]),
          (combinedRet[i]==null?'':combinedRet[i]),
          (combinedLogRet[i]==null?'':combinedLogRet[i])];
        const navs=labels.map(lb=> (alignedNormUnion[lb][i]==null?'':alignedNormUnion[lb][i]));
        const rts=labels.map(lb=> (perLabelRets[lb][i]==null?'':perLabelRets[lb][i]));
        const lrts=labels.map(lb=> (perLabelLogRets[lb][i]==null?'':perLabelLogRets[lb][i]));
        return base.concat(navs).concat(rts).concat(lrts).join(',');
      });
      const blob=new Blob([header+rows.join('\\n')],{type:'text/csv;charset=utf-8'});
      saveAs(blob, 'combined_strategy.csv');
    };

    // Mode toggles
    cumModeToggle.onclick=(ev)=>{
      const btn=ev.target.closest('button'); if(!btn) return;
      cumMode=btn.dataset.mode; localStorage.setItem('cumMode', cumMode);
      document.querySelectorAll('#cumModeToggle button').forEach(b=> b.classList.remove('active'));
      btn.classList.add('active'); rebuildAll();
    };

    rangeButtons.forEach(b=> b.onclick=()=>{
      const maxD=DateTime.fromISO(unionDates[unionDates.length-1]);
      let minD=DateTime.fromISO(unionDates[0]);
      const mode=b.dataset.range;
      if(mode==='10y') minD=maxD.minus({years:10});
      else if(mode==='5y') minD=maxD.minus({years:5});
      else if(mode==='1y') minD=maxD.minus({years:1});
      else if(mode==='ytd') minD=DateTime.fromObject({year:maxD.year,month:1,day:1});
      else if(mode==='all') minD=DateTime.fromISO(unionDates[0]);
      const minStr=minD.toISODate();
      startDateEl.value = (minStr < unionDates[0]) ? unionDates[0] : minStr;
      endDateEl.value = maxD.toISODate();
      rebuildAll();
    });

    // init cum toggle
    document.querySelectorAll('#cumModeToggle button').forEach(btn=> btn.classList.toggle('active', btn.dataset.mode===cumMode));

  });
})();
</script>
</body>
</html>
