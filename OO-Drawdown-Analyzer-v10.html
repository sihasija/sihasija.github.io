<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OO — Drawdown Analyzer v6</title>
<style>
:root{
  --bg:#0e1222; --panel:#151a2e; --text:#e9edff; --muted:#a9b3d9;
  --accent:#6ea2ff; --bad:#ff6b6b; --grid:#273058; --border:rgba(255,255,255,.12);
  --chip:#1b2447; --shadow:0 14px 36px rgba(0,0,0,.35); --radius:18px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:radial-gradient(1000px 520px at 18% -10%, #1a2350 0%, #0e1222 55%);
  color:var(--text);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  font-size:14px;
}
.container{max-width:1200px;margin:18px auto;padding:0 12px;}
.header{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
h1{margin:0;font-size:22px;letter-spacing:.2px}
.version{font-size:11px;color:var(--muted);border:1px solid var(--border);padding:3px 8px;border-radius:999px}
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.05),transparent 45%) border-box, var(--panel);
  border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)
}
.controls{padding:12px;display:grid;gap:10px;grid-template-columns:1fr}
/* First row: big upload + drop box side-by-side */
.controls .row.upload{
  display:grid; gap:10px;
  grid-template-columns: 260px 1fr;
  align-items:stretch;
}
@media (max-width:720px){
  .controls .row.upload{ grid-template-columns: 1fr; }
}
.controls .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

.btn{
  appearance:none;background:linear-gradient(180deg,#3d5fff,#2a47c9);color:white;
  font-weight:800;padding:16px 18px;border-radius:12px;border:1px solid rgba(255,255,255,.18);
  cursor:pointer;box-shadow:0 10px 26px rgba(61,95,255,.35);font-size:15px;min-height:56px;
}
.btn.secondary{background:linear-gradient(180deg,#1a244d,#151c39);color:var(--muted)}

.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:var(--chip);border:1px solid var(--border);border-radius:999px;color:var(--muted);font-size:12px}
input[type="file"]{display:none}
label[for="file"]{cursor:pointer}

/* Inline drag-drop box */
#dropBox{
  border:2px dashed rgba(255,255,255,.20);
  border-radius:12px;
  background:rgba(255,255,255,.04);
  color:var(--muted);
  display:flex; align-items:center; justify-content:center;
  padding:10px;
  text-align:center;
  font-size:13px;
}
#dropBox.dragover{border-color:#9cffdb;background:rgba(156,255,219,.08);color:var(--text)}

/* Strategy toggles: dynamic wrap, no scrollbar */
#strategyPills{
  display:flex;gap:6px;flex-wrap:wrap;
  padding:6px;border-radius:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);
}
.chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:#131a33;border:1px solid var(--border);font-size:12px}
.chip input{accent-color:#6ea2ff;transform:scale(.9)}

.legend{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:12px;padding:8px 12px}
.chart{padding:6px 6px 8px}
svg{width:100%;height:380px;display:block}
.grid line{stroke:var(--grid);stroke-width:1;opacity:.6}
.axis text{fill:var(--muted);font-size:10px}
.axis path{stroke:var(--grid);opacity:.6}
.area{fill:rgba(255,107,107,.35);stroke:rgba(255,107,107,.8);stroke-width:1.3}
.zero{stroke:rgba(255,255,255,.25);stroke-dasharray:4 4}
.indiv path{fill:none;stroke-width:1.3;opacity:.85}

.kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;padding:10px}
.kpi{background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:10px;padding:8px}
.kpi .label{color:var(--muted);font-size:11px}
.kpi .value{font-size:16px;font-weight:800;margin-top:2px}

/* nav pills with stacked Start/End NAV */
.stat-pill{display:flex;flex-direction:column;align-items:flex-start;gap:2px}
.stat-pill strong{font-weight:700;color:#c9d2ff}
.stat-pill .sub{font-size:11.5px;color:var(--muted)}

/* Stats table */
.stats-card{margin-top:14px; padding:10px;}
.table-wrap{overflow:auto; border-top:1px solid var(--border);}
table{width:100%; border-collapse:separate; border-spacing:0; font-size:12px; min-width:1000px}
thead th{
  position:sticky; top:0; background:#0f1430; z-index:1;
  text-align:left; padding:10px 8px; border-bottom:1px solid var(--border); color:#c9d2ff; font-weight:700;
}
tbody td{padding:8px; border-bottom:1px solid rgba(255,255,255,.08); color:#e5e9ff}
tbody tr:nth-child(odd){background:rgba(255,255,255,.03)}
tfoot td{padding:8px; color:var(--muted); font-size:11px}
th:first-child, td:first-child{position:sticky; left:0; background:inherit}
.right{text-align:right; white-space:nowrap}
.bad{color:#ff9a9a}
.good{color:#8be0b0}
.badge {display:inline-flex;align-items:center;gap:6px}
.badge input{transform:scale(.95); accent-color:#6ea2ff}

/* Monthly returns table */
#monthlyCard { margin-top: 14px; padding: 10px; }
#monthlyTable { width: 100%; border-collapse: separate; border-spacing: 0; font-size:12px; min-width: 900px; }
#monthlyTable thead th{
  position:sticky; top:0; background:#0f1430; z-index:1;
  text-align:right; padding:10px 8px; border-bottom:1px solid var(--border); color:#c9d2ff; font-weight:700;
}
#monthlyTable thead th:first-child{ text-align:left; }
#monthlyTable tbody td{ padding:8px; border-bottom:1px solid rgba(255,255,255,.08); color:#e5e9ff; text-align:right }
#monthlyTable tbody td:first-child{ text-align:left }
#monthlyTable tbody tr:nth-child(odd){ background:rgba(255,255,255,.03) }

#monthlyTable td.good { color:#4caf50; font-weight:600; }
#monthlyTable td.bad { color:#ff5252; font-weight:600; }

#monthlyTable th:first-child, #monthlyTable td:first-child{ position:sticky; left:0; background:inherit }

</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>OO — Drawdown Analyzer</h1>
      <span class="version">v6</span>
    </div>
    <div class="small" style="margin:6px 0 10px">Upload your trade log, toggle strategies, and analyze combined drawdown. The drop area is right next to the upload button.</div>

    <section class="card controls">
      <!-- First row: big upload button + drop box -->
      <div class="row upload">
        <div>
          <label class="btn" for="file">Upload CSV</label>
          <input id="file" type="file" accept=".csv"/>
        </div>
        <div id="dropBox">…or drop a CSV file here</div>
      </div>

      <!-- Second row: stats and options -->
      <div class="row">
        <div class="pill stat-pill">
          <div><strong>Start NAV:</strong> <span id="startNav">$—</span></div>
          <div class="sub"><strong>Ending NAV:</strong> <span id="endNav">$—</span></div>
        </div>
        <div class="pill"><strong style="opacity:.9">Trades:</strong> <span id="tradeCount" style="margin-left:4px">0</span></div>
        <label class="pill badge" title="Show/hide per-strategy drawdown overlays">
          <input type="checkbox" id="toggleIndiv" />
          Show individual strategies
        </label>
        <div class="pill"><button class="btn secondary" id="allBtn">All</button><button class="btn secondary" id="noneBtn">None</button></div>
      </div>

      <!-- Strategy toggles -->
      <div id="strategyPills"></div>
    </section>

    <section class="card chart" id="chartCard">
      <div class="legend">Drawdown from equity peak (based on cumulative P/L). Combined area in red; optional per-strategy overlays are thin colored lines.</div>
      <svg id="chart" viewBox="0 0 900 380" preserveAspectRatio="none" aria-label="Drawdown chart">
        <defs>
          <linearGradient id="fill" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="rgba(255,107,107,.55)"/>
            <stop offset="100%" stop-color="rgba(255,107,107,0)"/>
          </linearGradient>
        </defs>
        <g class="grid"></g>
        <g class="axis axis-x"></g>
        <g class="axis axis-y"></g>
        <path class="area" d=""></path>
        <g class="indiv"></g>
        <line class="zero" x1="50" y1="320" x2="860" y2="320"></line>
      </svg>
      <div class="kpis">
        <div class="kpi"><div class="label">Max Drawdown</div><div class="value" id="maxDD">—</div></div>
        <div class="kpi"><div class="label">Longest Drawdown (days)</div><div class="value" id="longDD">—</div></div>
      </div>
    </section>

    <section class="card stats-card">
      <div class="legend">Per-strategy statistics (computed from each strategy’s equity curve with the same Start NAV baseline). Returns are as of the last date in your file.</div>
      <div class="table-wrap">
        <table id="statsTable">
          <thead>
            <tr>
              <th>Strategy</th>
              <th class="right">Sharpe</th>
              <th class="right">Calmar</th>
              <th class="right">Worst DD</th>
              <th>Date of Worst DD</th>
              <th class="right">All-time PnL %</th>
              <th class="right">Last 1Y %</th>
              <th class="right">YTD %</th>
              <th class="right">6M %</th>
              <th class="right">3M %</th>
              <th class="right">1M %</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr><td colspan="11">Notes: Sharpe uses daily close-to-close returns (rf=0, 252 trading days). Calmar = CAGR / |Max DD|. Window returns use the last available value on/after the boundary and the most recent value in the series.</td></tr>
          </tfoot>
        </table>
      </div>
    </section>


    <section class="card stats-card" id="monthlyCard">
      <div class="legend">Monthly returns by strategy (single-month % returns). Columns are relative to the most recent month in your data: 12M (12 months ago) → Current. If the current month is December, the 12M column shows the return for the previous January.</div>
      <div class="table-wrap">
        <table id="monthlyTable">
          <thead>
            <tr id="monthlyHead"></tr>
          </thead>
          <tbody id="monthlyBody"></tbody>
        </table>
      </div>
    </section>

    <div class="foot">Expected columns: <code>Strategy</code>, <code>P/L</code>, <code>Date Closed</code> (and optionally <code>Time Closed</code>, <code>Funds at Close</code>). Uses earliest <em>Funds at Close</em> as Start NAV if present; else 100,000.</div>
  </div>

<script>
(function(){
  const fileInput = document.getElementById('file');
  const startNavEl= document.getElementById('startNav');
  const endNavEl  = document.getElementById('endNav');
  const tradeCountEl= document.getElementById('tradeCount');
  const pillsWrap = document.getElementById('strategyPills');
  const allBtn    = document.getElementById('allBtn');
  const noneBtn   = document.getElementById('noneBtn');
  const showIndiv = document.getElementById('toggleIndiv');
  const dropBox   = document.getElementById('dropBox');

  const svg = document.getElementById('chart');
  const gridG = svg.querySelector('.grid');
  const xAxisG = svg.querySelector('.axis-x');
  const yAxisG = svg.querySelector('.axis-y');
  const areaPath = svg.querySelector('.area');
  const indivG  = svg.querySelector('.indiv');
  const maxDDEl = document.getElementById('maxDD');
  const longDDEl = document.getElementById('longDD');
  const statsTable = document.getElementById('statsTable').querySelector('tbody');

  let rawRows = [];
  let byStrategy = new Map();
  let selected = new Set();
  let startNAV = 100000;

  fileInput.addEventListener('change', async (e)=>{
    if (!e.target.files?.length) return;
    const file = e.target.files[0];
    await loadFile(file);
  });

  allBtn.addEventListener('click', ()=>{ selected = new Set(byStrategy.keys()); update(); });
  noneBtn.addEventListener('click', ()=>{ selected = new Set(); update(); });
  showIndiv.addEventListener('change', ()=> update());
  pillsWrap.addEventListener('change', ()=> update());

  ;['dragenter','dragover'].forEach(t => {
    dropBox.addEventListener(t, (e)=>{ e.preventDefault(); e.stopPropagation(); dropBox.classList.add('dragover'); });
  });
  ;['dragleave','drop'].forEach(t => {
    dropBox.addEventListener(t, (e)=>{
      e.preventDefault(); e.stopPropagation();
      if (t==='drop') handleDrop(e);
      dropBox.classList.remove('dragover');
    });
  });
  async function handleDrop(e){
    const f = e.dataTransfer?.files?.[0];
    if (f) await loadFile(f);
  }

  async function loadFile(file){
    const text = await file.text();
    const rows = parseCSV(text);
    rawRows = rows;
    tradeCountEl.textContent = rows.length.toString();

    // Discover columns (case-insensitive)
    const cols = Object.keys(rows[0]||{}).reduce((acc,k)=>{ acc[k.toLowerCase()] = k; return acc; },{});
    const colStrategy = cols['strategy'] || 'Strategy';
    const colPL = cols['p/l'] || cols['p&l'] || cols['pl'] || 'P/L';
    const colDateClosed = cols['date closed'] || cols['closed date'] || cols['date'] || 'Date Closed';
    const colTimeClosed = cols['time closed'] || cols['closed time'] || 'Time Closed';
    const colFundsAtClose = cols['funds at close'] || cols['nav'] || 'Funds at Close';

    // Parse + normalize
    const parsed = rows.map(r=>{
      const s = String(r[colStrategy] ?? '').trim();
      const pl = toNum(r[colPL]);
      const d  = parseDate(r[colDateClosed], r[colTimeClosed]);
      const nav= toNum(r[colFundsAtClose]);
      return {Strategy:s, PL:pl, Closed:d, FundsAtClose: isFinite(nav)?nav:undefined};
    }).filter(r => r.Closed instanceof Date && !isNaN(r.Closed));

    // Build start NAV if present
    const withNav = parsed.filter(r => r.FundsAtClose!==undefined).sort((a,b)=>a.Closed-b.Closed);
    startNAV = withNav.length ? withNav[0].FundsAtClose : 100000;
    startNavEl.textContent = formatUSD(startNAV);

    // Bucket strategies
    byStrategy = new Map();
    for (const r of parsed){
      if (!byStrategy.has(r.Strategy)) byStrategy.set(r.Strategy, []);
      byStrategy.get(r.Strategy).push(r);
    }
    // default select all
    selected = new Set(byStrategy.keys());

    // Build strategy pills
    pillsWrap.innerHTML = '';
    for (const [name, arr] of [...byStrategy.entries()].sort((a,b)=>a[0].localeCompare(b[0]))){
      const id = 's_' + hash(name);
      const chip = document.createElement('label');
      chip.className = 'chip';
      chip.innerHTML = `<input type="checkbox" id="${id}" checked /><span>${escapeHtml(name)}</span><span class="small" style="opacity:.7">(${arr.length})</span>`;
      pillsWrap.appendChild(chip);
      chip.querySelector('input').addEventListener('change', (e)=>{
        if (e.target.checked) selected.add(name); else selected.delete(name);
        // update() fired by pillsWrap listener
      });
    }

    update();
  }

  function update(){
    const subset = [];
    const selectedList = [];
    for (const [name, arr] of byStrategy.entries()){
      if (selected.has(name)) { subset.push(...arr); selectedList.push([name, arr]); }
    }
    // Combined equity from cumulative P/L of subset
    subset.sort((a,b)=>a.Closed-b.Closed);
    const combinedPts = ddPointsFromTrades(subset, startNAV);

    // Ending NAV: last equity of combined series, or start if empty
    const endEq = combinedPts.length ? combinedPts[combinedPts.length-1].eq : startNAV;
    endNavEl.textContent = formatUSD(endEq);

    // Per-strategy overlays (each computed independently with same starting NAV for comparability)
    const perSeries = [];
    for (const [name, arr] of selectedList){
      const sorted = arr.slice().sort((a,b)=>a.Closed-b.Closed);
      const pts = ddPointsFromTrades(sorted, startNAV);
      perSeries.push({ name, pts, trades: sorted });
    }

    // KPIs from combined only
    const maxDD = combinedPts.reduce((m,p)=>Math.min(m,p.y), 0);
    const longest = longestDrawdown(combinedPts.map(p=>p.y));
    maxDDEl.textContent = (combinedPts.length===0)?'—':formatPct(maxDD);
    longDDEl.textContent = (combinedPts.length===0)?'—':String(longest);

    draw(combinedPts, showIndiv.checked ? perSeries : []);

    // Stats table for selected strategies
    renderStats(perSeries);
    renderMonthly(perSeries);
  }
  // Build drawdown % points from list of trades
  function ddPointsFromTrades(trades, start){
    const points = [];
    let equity = start;
    let peak = start;
    const daily = new Map();
    for (const r of trades){
      equity += (isFinite(r.PL)?r.PL:0);
      const day = ymd(r.Closed);
      const t = r.Closed.getTime();
      const prev = daily.get(day);
      if (!prev || t >= prev.t){
        daily.set(day, {eq:equity, t});
      }
    }
    const days = [...daily.keys()].sort();
    for (const day of days){
      const eq = daily.get(day).eq;
      peak = Math.max(peak, eq);
      const dd = (eq - peak) / peak; // <= 0
      points.push({x: new Date(day), y: dd, eq});
    }
    return points;
  }

  function renderStats(series){
    statsTable.innerHTML = '';
    for (const s of series){
      const eqSeries = s.pts; // has {x, y (dd), eq}
      if (!eqSeries.length){
        addRow(s.name, {Sharpe:NaN, Calmar:NaN, worstDD:NaN, worstDate:null, all:NaN, t1y:NaN, ytd:NaN, t6m:NaN, t3m:NaN, t1m:NaN});
        continue;
      }

      const returns = [];
      for (let i=1;i<eqSeries.length;i++){
        const r = eqSeries[i].eq / eqSeries[i-1].eq - 1;
        if (isFinite(r)) returns.push(r);
      }
      const sharpe = calcSharpe(returns);

      const firstEq = eqSeries[0].eq;
      const lastEq  = eqSeries[eqSeries.length-1].eq;
      const firstDate = eqSeries[0].x;
      const lastDate = eqSeries[eqSeries.length-1].x;
      const years = Math.max( (lastDate - firstDate) / (365.25*24*3600*1000), 0);
      const cagr = (years>0 && firstEq>0) ? Math.pow(lastEq/firstEq, 1/years) - 1 : NaN;
      const worst = eqSeries.reduce((acc,p)=> p.y < acc.y ? p : acc, eqSeries[0]);
      const calmar = (isFinite(cagr) && worst.y < 0) ? (cagr / Math.abs(worst.y)) : NaN;

      // Window returns
      const all = pct(firstEq, lastEq);
      const t1y = windowReturn(eqSeries, daysOffset(lastDate, -365));
      const ytd = windowReturn(eqSeries, new Date(lastDate.getFullYear(), 0, 1));
      const t6m = windowReturn(eqSeries, daysOffset(lastDate, -182));
      const t3m = windowReturn(eqSeries, daysOffset(lastDate, -91));
      const t1m = windowReturn(eqSeries, daysOffset(lastDate, -30));

      addRow(s.name, {
        Sharpe: sharpe,
        Calmar: calmar,
        worstDD: worst.y,
        worstDate: worst.x,
        all, t1y, ytd, t6m, t3m, t1m
      });
    }
  }

  function addRow(name, m){
    const tr = document.createElement('tr');
    function td(v, cls='', alignRight=false){
      const el = document.createElement('td');
      el.innerHTML = v;
      if (cls) el.classList.add(cls);
      if (alignRight) el.classList.add('right');
      tr.appendChild(el);
    }
    td(escapeHtml(name));
    td(formatNum(m.Sharpe,2), '', true);
    td(formatNum(m.Calmar,2), '', true);
    td(formatPct(m.worstDD), m.worstDD<0?'bad':'' , true);
    td(m.worstDate? dateLabel(m.worstDate): '—');
    td(formatPct(m.all), (m.all>=0?'good':'bad'), true);
    td(formatPct(m.t1y), (m.t1y>=0?'good':'bad'), true);
    td(formatPct(m.ytd), (m.ytd>=0?'good':'bad'), true);
    td(formatPct(m.t6m), (m.t6m>=0?'good':'bad'), true);
    td(formatPct(m.t3m), (m.t3m>=0?'good':'bad'), true);
    td(formatPct(m.t1m), (m.t1m>=0?'good':'bad'), true);
    statsTable.appendChild(tr);
  }

  function windowReturn(eqSeries, startDate){
    if (!eqSeries.length) return NaN;
    const endEq = eqSeries[eqSeries.length-1].eq;
    // find the last point on or before startDate; if none, use first
    let baseEq = eqSeries[0].eq;
    for (let i=0;i<eqSeries.length;i++){
      if (eqSeries[i].x <= startDate) baseEq = eqSeries[i].eq;
      else break;
    }
    return pct(baseEq, endEq);
  }

  function pct(a, b){ if (!isFinite(a) || a<=0 || !isFinite(b)) return NaN; return b/a - 1; }

  // ---------- Chart (SVG) ----------
  function draw(points, perSeries){
    const width = 900, height = 380, padL=48, padR=36, padT=18, padB=34;
    const innerW = width - padL - padR;
    const innerH = height - padT - padB;
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const seriesDates = points.map(p=>p.x);
    for (const s of perSeries){ for (const p of s.pts){ seriesDates.push(p.x); } }

    // Scales
    const xs = (d)=>{
      if (!seriesDates.length) return padL;
      const minX = +seriesDates[0], maxX = +seriesDates[seriesDates.length-1];
      if (minX===maxX) return padL + innerW/2;
      return padL + ( (+d - minX) / (maxX - minX) ) * innerW;
    };
    const allY = points.concat(...perSeries.map(s=>s.pts));
    const minY = Math.min(0, (allY.reduce((m,p)=>Math.min(m,p.y), 0) || 0) * 1.05);
    const ys = (v)=> padT + (1 - ( (v - minY) / (0 - minY) )) * innerH;

    // Grid + axes
    gridG.innerHTML = '';
    xAxisG.innerHTML = '';
    yAxisG.innerHTML = '';

    // sort seriesDates for ticks
    seriesDates.sort((a,b)=>+a-+b);

    // Y ticks
    const yTicks = tickStep(minY, 0, 5);
    for (const v of yTicks){
      const y = ys(v);
      const l = line(padL, y, width-padR, y);
      l.setAttribute('class','grid');
      gridG.appendChild(l);

      const txt = text(padL-6, y+3, formatPct(v));
      txt.setAttribute('text-anchor','end');
      yAxisG.appendChild(txt);
    }
    yAxisG.appendChild(line(padL, ys(0), width-padR, ys(0))).setAttribute('class','zero');

    // X ticks (dates)
    const xTicks = xTickDates(seriesDates, 6);
    for (const d of xTicks){
      const x = xs(d);
      const l = line(x, padT, x, height-padB);
      l.setAttribute('class','grid');
      gridG.appendChild(l);

      const lbl = dateLabel(d);
      const txt = text(x, height-padB+12, lbl);
      txt.setAttribute('text-anchor','middle');
      xAxisG.appendChild(txt);
    }

    // Combined area
    if (!points.length){
      areaPath.setAttribute('d','');
    } else {
      const d = [];
      d.push(`M ${xs(points[0].x)} ${ys(0)}`);
      for (const p of points){ d.push(`L ${xs(p.x)} ${ys(p.y)}`); }
      d.push(`L ${xs(points[points.length-1].x)} ${ys(0)} Z`);
      areaPath.setAttribute('d', d.join(' '));
      areaPath.setAttribute('fill','url(#fill)');
    }

    // Per-strategy overlays
    indivG.innerHTML = '';
    if (perSeries && perSeries.length){
      for (const s of perSeries){
        if (!s.pts.length) continue;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        const d=[];
        d.push(`M ${xs(s.pts[0].x)} ${ys(s.pts[0].y)}`);
        for (const p of s.pts.slice(1)){ d.push(`L ${xs(p.x)} ${ys(p.y)}`); }
        path.setAttribute('d', d.join(' '));
        const hue = (hash(s.name) % 360);
        path.setAttribute('stroke', `hsl(${hue} 70% 65%)`);
        path.setAttribute('class', 'indiv-line');
        indivG.appendChild(path);
      }
      indivG.setAttribute('class','indiv');
      indivG.style.display = 'block';
    } else {
      indivG.innerHTML = '';
      indivG.style.display = 'none';
    }
  }

  // ---------- Utils ----------
  function line(x1,y1,x2,y2){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
    return l;
  }
  function text(x,y,txt){
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x',x); t.setAttribute('y',y); t.textContent = txt; return t;
  }
  function xTickDates(dates, n){
    if (!dates.length) return [];
    const min = +dates[0], max = +dates[dates.length-1];
    const out = [];
    for (let i=0;i<n;i++){
      const t = min + (i/(n-1))*(max-min);
      out.push(new Date(t));
    }
    return out;
  }
  function dateLabel(d){
    const y=d.getFullYear();
    const m=d.getMonth()+1, mm = m<10? '0'+m:m;
    const day=d.getDate(), dd = day<10? '0'+day:day;
    return `${y}-${mm}-${dd}`;
  }
  function tickStep(min, max, count){
    const step = (max-min)/count;
    const out = [];
    for (let i=0;i<=count;i++) out.push(min + i*step);
    return out;
  }
  function longestDrawdown(dds){ // dds <= 0
    let longest=0, cur=0;
    for (const v of dds){
      if (v<0) { cur++; longest=Math.max(longest,cur); }
      else cur=0;
    }
    return longest;
  }
  function parseCSV(text){
    // Minimal CSV parser supporting quoted fields with commas and "" escapes
    const rows=[]; let i=0; const len=text.length;
    let row=[], field='', inQuotes=false;
    function endField(){ row.push(field); field=''; }
    function endRow(){ rows.push(row); row=[]; }
    while(i<len){
      const c = text[i];
      if (inQuotes){
        if (c === '"'){
          if (text[i+1] === '"'){ field+='"'; i+=2; continue; }
          inQuotes=false; i++; continue;
        } else { field+=c; i++; continue; }
      } else {
        if (c === '"'){ inQuotes=true; i++; continue; }
        if (c === ','){ endField(); i++; continue; }
        if (c === '\r'){ i++; continue; }
        if (c === '\n'){ endField(); endRow(); i++; continue; }
        field+=c; i++; continue;
      }
    }
    endField(); endRow();
    // header -> objects
    const header = rows.shift() || [];
    const keys = header.map(h=>String(h||'').trim());
    const out = rows.filter(r=>r.length>1 || (r[0] && r[0].trim()!=='')).map(r=>{
      const o={};
      for (let j=0;j<keys.length;j++) o[keys[j]]=r[j]!==undefined?r[j]:'';
      return o;
    });
    return out;
  }
  function parseDate(d, t){
    const s = (d??'').toString().trim();
    if (!s) return new Date(NaN);
    let ts = (t??'').toString().trim();
    if (!ts) ts = '16:00:00';
    let d1 = new Date(s + 'T' + ts);
    if (!isNaN(d1)) return d1;
    if (/^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(s)){
      const [m,d2,y]=s.split('/').map(x=>parseInt(x,10));
      const Y = y<100? 2000+y : y;
      return new Date(Y, m-1, d2, ...ts.split(':').map(x=>parseInt(x,10)));
    }
    return new Date(s);
  }
  function toNum(v){
    if (v===undefined || v===null) return NaN;
    const s = String(v).replace(/[$,%\s]/g,'').replace(/,/g,'');
    const n = Number(s);
    return isFinite(n)?n:NaN;
  }
  function formatUSD(n){
    try { return n.toLocaleString(undefined,{style:'currency',currency:'USD',maximumFractionDigits:0}); }
    catch { return '$'+Math.round(n).toString(); }
  }
  function formatNum(n, d=2){
    if (!isFinite(n)) return '—';
    return (Math.round(n*Math.pow(10,d))/Math.pow(10,d)).toFixed(d);
  }
  function formatPct(v){
    if (!isFinite(v)) return '—';
    const p = (v*100);
    const s = (Math.round(p*10)/10).toFixed(1) + '%';
    return s;
  }
  function daysOffset(d, days){ return new Date(d.getTime() + days*24*3600*1000); }
  function mean(a){ if (!a.length) return NaN; return a.reduce((s,x)=>s+x,0)/a.length; }
  function stdev(a){ if (a.length<2) return NaN; const m=mean(a); const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/(a.length-1); return Math.sqrt(v); }
  function calcSharpe(daily){ const mu=mean(daily); const sd=stdev(daily); if (!isFinite(mu)||!isFinite(sd)||sd===0) return NaN; return (mu/sd)*Math.sqrt(252); }
  function ymd(d){ return d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0'); }
  function hash(s){ let h=0; for (let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); }
  function escapeHtml(str){ return str.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;', '"':'&quot;', "'":'&#39;' }[m])); }
  function tickStep(min, max, count){
    const step = (max-min)/count;
    const out = [];
    for (let i=0;i<=count;i++) out.push(min + i*step);
    return out;
  }
  function xTickDates(dates, n){
    if (!dates.length) return [];
    const min = +dates[0], max = +dates[dates.length-1];
    const out = [];
    for (let i=0;i<n;i++){
      const t = min + (i/(n-1))*(max-min);
      out.push(new Date(t));
    }
    return out;
  }
  function dateLabel(d){
    const y=d.getFullYear();
    const m=d.getMonth()+1, mm = m<10? '0'+m:m;
    const day=d.getDate(), dd = day<10? '0'+day:day;
    return `${y}-${mm}-${dd}`;
  }
    // ---- Monthly Returns (per-strategy) ----
    function renderMonthly(perSeries){
      const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const headRow = document.getElementById('monthlyHead');
      const body    = document.getElementById('monthlyBody');
      headRow.innerHTML = ''; body.innerHTML = '';

      // Determine the "current" month from the latest date across selected series
      let lastDate = null;
      for (const s of perSeries){
        const pts = s.pts;
        if (pts && pts.length){
          const d = pts[pts.length-1].x;
          if (!lastDate || +d > +lastDate) lastDate = d;
        }
      }
      if (!lastDate){
        // Only header with Strategy when no data
        const th = document.createElement('th'); th.textContent = 'Strategy'; headRow.appendChild(th);
        return;
      }
      // Build month list: offsets 12..0 (12M ago to current month)
      const curY = lastDate.getFullYear();
      const curM = lastDate.getMonth(); // 0-11
      const months = [];
      for (let k=12; k>=0; k--){
        // Compute target Y,M as cur month minus k
        let y = curY, m = curM - k;
        while (m < 0){ m += 12; y -= 1; } // wrap months, subtract ONE year per 12 months
        months.push({y,m});
      }

      // Build header
      const thS = document.createElement('th'); thS.textContent = 'Strategy'; headRow.appendChild(thS);
      for (let i=0;i<months.length;i++){
        const th = document.createElement('th');
        if (i === months.length-1){
          th.textContent = 'Current';
        } else {
          const offset = 12 - i;
          th.textContent = (offset === 12 ? '12M' : (offset+'M'));
        }
        headRow.appendChild(th);
      }

      // Helper: compute single-month return for a given Y,M from an equity series (points have .x date and .eq equity)
      function monthEndReturn(eqSeries, Y, M){
        if (!eqSeries || !eqSeries.length) return NaN;
        // end of target month
        const endTarget = new Date(Y, M+1, 0, 23, 59, 59);
        // end of previous month
        const endPrev   = new Date(Y, M, 0, 23, 59, 59);

        // Find last equity on/before endTarget and endPrev
        let eqEnd = null, eqPrev = null;
        for (let i=0;i<eqSeries.length;i++){
          const d = eqSeries[i].x;
          const eq = eqSeries[i].eq;
          if (d <= endTarget) eqEnd = eq;
          if (d <= endPrev)   eqPrev = eq;
          if (d > endTarget) break;
        }
        if (!isFinite(eqEnd) || !isFinite(eqPrev) || eqPrev <= 0) return NaN;
        return (eqEnd/eqPrev) - 1;
      }

      // Rows
      for (const s of perSeries){
        const tr = document.createElement('tr');
        const tdName = document.createElement('td'); tdName.textContent = s.name; tr.appendChild(tdName);
        for (let i=0;i<months.length;i++){
          const {y,m} = months[i];
          const r = monthEndReturn(s.pts, y, m);
          const td = document.createElement('td');
          const label = monthNames[m] + ' ' + y;
          if (isFinite(r)){
            const pct = formatPct(r);
            td.textContent = pct;
            td.title = label + ' — ' + pct;
            td.className = r >= 0 ? 'good right' : 'bad right';
          } else {
            td.textContent = '—';
            td.title = label;
            td.className = 'right';
          }
          tr.appendChild(td);
        }
        body.appendChild(tr);
      }
    }

})();
</script>
</body>
</html>
